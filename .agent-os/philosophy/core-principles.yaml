---
# Core Development Philosophy
# The fundamental principles that guide all technical decisions

core_philosophy:
  name: "Cost-First Development with Pragmatic Simplicity"
  
  primary_principles:
    cost_optimization:
      rule: "always_choose_cheapest_viable_option"
      application: "Every model call, API choice, infrastructure decision"
      examples:
        - "Use cheap models for simple queries, premium for complex"
        - "Choose existing libraries over custom builds"
        - "Optimize for token efficiency over feature richness"
        
    simplicity_over_sophistication:
      rule: "prefer_simple_solutions_over_complex_ones"
      application: "Architecture, code, configuration, documentation"
      examples:
        - "Text file logging vs database analytics"
        - "YAML config vs complex UI settings"
        - "Wrapper approach vs rebuilding from scratch"
        
    existing_over_custom:
      rule: "use_existing_libraries_and_tools_first"
      application: "Never build what already exists and works"
      examples:
        - "LiteLLM for model routing vs custom router"
        - "Agent-OS for workflows vs custom task system"
        - "OpenCat iOS app vs building custom mobile app"
        
    graceful_degradation:
      rule: "build_fallbacks_not_perfect_systems"
      application: "Always have a working fallback when advanced features fail"
      examples:
        - "Intelligence optimization fails → direct model calls"
        - "Agent-OS unavailable → simple command execution"
        - "OpenRouter down → critical failure (acceptable)"
        
    configuration_over_code:
      rule: "prefer_config_files_over_hard_coding"
      application: "Make behavior configurable without code changes"
      examples:
        - "Model tiers in YAML not hardcoded"
        - "Intent mappings in config files"
        - "Cost limits in environment variables"
        
    minimal_viable_solutions:
      rule: "implement_smallest_working_solution_first"
      application: "Build the minimum that solves the problem"
      examples:
        - "20-line intelligence router vs complex ML system"
        - "3-5 token context vs full conversation analysis"
        - "Text file cost tracking vs real-time dashboard"

decision_framework:
  when_choosing_solutions:
    1: "What's the cheapest option that works?"
    2: "What's the simplest approach?"
    3: "Does this already exist somewhere?"
    4: "What happens when this fails?"
    5: "Can this be configured vs coded?"
    6: "What's the minimum viable version?"
    
  optimization_priorities:
    1: "Cost (most important)"
    2: "Simplicity" 
    3: "Reliability"
    4: "Speed (least important - if it saves money, take 8 seconds vs 5)"
    
  complexity_thresholds:
    rule: "if_solution_requires_more_than_X_reject_it"
    thresholds:
      - "More than 100 lines of code → find simpler approach"
      - "More than 3 dependencies → use existing solution"
      - "More than 1 config file → consolidate"
      - "More than 2 hours to implement → question necessity"

anti_patterns_to_avoid:
  over_engineering:
    - "Building frameworks when scripts suffice"
    - "Complex abstractions for simple problems"
    - "Perfect solutions when good-enough works"
    
  feature_creep:
    - "Adding features 'because we can'"
    - "Solving problems users don't have"
    - "Building for theoretical future needs"
    
  technology_for_technology_sake:
    - "Using latest tech because it's new"
    - "Rebuilding working systems with trendy tools"
    - "Adding complexity to seem sophisticated"
    
  perfectionism:
    - "100% test coverage for simple scripts"
    - "Enterprise patterns for personal projects"
    - "Over-documentation of obvious functionality"

success_metrics:
  cost_efficiency:
    - "Reduces total API costs vs baseline"
    - "Uses minimum required model tiers"
    - "Eliminates unnecessary API calls"
    
  simplicity:
    - "Can be understood by reading one file"
    - "Can be configured without code changes"
    - "Can be debugged with simple tools"
    
  reliability:
    - "Fails gracefully with clear fallbacks"
    - "Works even when advanced features break"
    - "Requires minimal maintenance"
    
  speed_to_value:
    - "Solves user problem within days not months"
    - "Can be deployed immediately"
    - "Provides immediate value over perfect future value"
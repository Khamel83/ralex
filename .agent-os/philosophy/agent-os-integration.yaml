---
# Agent-OS Integration Philosophy
# How to embed philosophy into automated task execution

agent_os_integration:
  name: "Philosophy-Driven Automation"
  
  core_concept:
    embed_principles: "Every agent-os task automatically follows cost-first philosophy"
    decision_guidance: "Agent knows how to make trade-offs without asking"
    consistency: "Same principles applied whether human or AI makes decisions"
    learning: "Philosophy embedded in context so future tasks improve"

task_specification_structure:
  required_sections:
    core_principles:
      cost_optimization: "Always choose cheapest viable option"
      simplicity_preference: "Simple solutions over complex ones"
      existing_over_custom: "Use existing tools first"
      graceful_degradation: "Build fallbacks not perfect systems"
      
    decision_framework:
      primary_target: "Cost first, speed second"
      complexity_threshold: "If complex, find simpler approach"
      dependency_preference: "Minimal new dependencies"
      testing_philosophy: "Pragmatic testing, not perfect coverage"
      
    philosophy_application:
      per_task_notes: "How principles apply to this specific task"
      trade_off_guidance: "Which principles to prioritize if they conflict"
      fallback_strategy: "What to do when optimal approach fails"

embedded_decision_making:
  when_choosing_approaches:
    cost_evaluation:
      question: "Which option costs less (time + money + maintenance)?"
      guidance: "Choose cheaper option even if 20% less capable"
      exception: "Only choose expensive if 3x better measured outcome"
      
    simplicity_evaluation:
      question: "Which option is easier to understand and debug?"
      guidance: "Prefer solution explainable in one paragraph"
      exception: "Accept complexity only for core business logic"
      
    dependency_evaluation:
      question: "How many new dependencies does each option add?"
      guidance: "Strongly prefer zero new dependencies"
      exception: "Accept dependencies only if well-maintained and essential"

automatic_trade_off_resolution:
  cost_vs_speed:
    default: "Choose cost optimization"
    example: "Take 8 seconds instead of 5 if it saves money"
    exception: "Choose speed only if user experience severely impacted"
    
  simple_vs_powerful:
    default: "Choose simplicity"
    example: "Text file logging instead of database analytics"
    exception: "Choose power only if simplicity can't solve user problem"
    
  existing_vs_perfect:
    default: "Choose existing solution"
    example: "Use LiteLLM routing instead of building perfect custom router"
    exception: "Build custom only if existing solutions can't be adapted"

task_execution_patterns:
  research_phase:
    1: "Search for existing solutions first"
    2: "Evaluate cost and complexity of top 3 options"
    3: "Choose based on embedded decision framework"
    4: "Document why choice was made"
    
  implementation_phase:
    1: "Start with minimum viable implementation"
    2: "Test basic functionality immediately"
    3: "Add features only if they provide measured value"
    4: "Include fallback mechanisms for each feature"
    
  validation_phase:
    1: "Measure actual cost/time improvements"
    2: "Test all fallback scenarios"
    3: "Verify setup works in fresh environment"
    4: "Document actual results vs predictions"

philosophy_embedding_techniques:
  context_injection:
    every_prompt: "Include cost-first philosophy summary"
    decision_points: "Reference specific principles when choosing"
    trade_offs: "Explicitly state which principle was prioritized"
    
  template_structure:
    philosophy_application: "How principles apply to this task"
    decision_rationale: "Why this approach over alternatives"
    cost_justification: "Expected cost/benefit analysis"
    fallback_plan: "What to do if this approach fails"
    
  validation_criteria:
    cost_effectiveness: "Is this the cheapest approach that works?"
    simplicity_check: "Can this be explained in one paragraph?"
    dependency_audit: "Are all dependencies necessary and maintained?"
    fallback_verification: "Do all fallback mechanisms work?"

learning_and_improvement:
  feedback_loops:
    measure_outcomes: "Track actual cost/time vs predictions"
    identify_patterns: "Which approaches consistently work best?"
    update_philosophy: "Refine principles based on real results"
    share_learnings: "Document successful patterns for reuse"
    
  philosophy_evolution:
    quarterly_review: "Evaluate if principles still serve goals"
    principle_refinement: "Make principles more specific based on experience"
    anti_pattern_identification: "Document what consistently fails"
    best_practice_codification: "Turn successful patterns into standard approaches"

agent_os_specific_features:
  task_chaining:
    philosophy_inheritance: "Each task in chain inherits philosophy from previous"
    context_preservation: "Cost/simplicity decisions carry forward"
    learning_accumulation: "Lessons learned improve subsequent tasks"
    
  parallel_execution:
    consistent_decisions: "All parallel tasks follow same principles"
    resource_optimization: "Coordinate to minimize total cost"
    graceful_coordination: "Tasks succeed independently when possible"
    
  error_handling:
    philosophy_aligned_fallbacks: "Fallbacks also follow cost-first principles"
    simple_error_recovery: "Prefer simple recovery over perfect error handling"
    cost_aware_retries: "Don't retry expensive operations excessively"

success_metrics_for_automation:
  cost_optimization:
    measure: "Total cost reduction vs manual implementation"
    target: "Agent-os tasks should cost 50% less than human equivalent"
    tracking: "Log all API calls, time spent, resource usage"
    
  consistency:
    measure: "Variance in decision-making across similar tasks"
    target: "90% of similar decisions should follow same pattern"
    tracking: "Document decision rationale for post-hoc analysis"
    
  learning_effectiveness:
    measure: "Improvement in task efficiency over time"
    target: "Each iteration should be 10% faster or cheaper"
    tracking: "Compare similar tasks executed at different times"
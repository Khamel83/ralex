# K83 Agentic Coding Workflows

> Last Updated: 2025-08-07
> Version: 1.0.0

## Overview

K83 agentic coding workflows enable autonomous development that follows Agent OS methodology while leveraging universal MCP integration. These workflows execute independently but remain transparent and interruptible.

## Core Agentic Commands

### `/yolo "build feature X"`
**Purpose:** Autonomous feature development from concept to working, tested code

**Workflow:**
1. **Analyze Request** - Parse feature requirements and scope
2. **Create Agent OS Spec** - Generate detailed specification following Agent OS templates
3. **Plan Implementation** - Break down into Agent OS tasks with MCP server integration
4. **Autonomous Development** - Execute tasks with automatic error handling
5. **Test & Validate** - Run tests, fix issues, iterate until success
6. **Context Preservation** - Save final state with git commit and memory storage

**MCP Integration:**
- **Sequential Thinking MCP** - Structured reasoning for complex problems
- **Memory Bank MCP** - Store decisions and patterns for future reference
- **GitHub MCP** - Automatic git operations and repository management
- **FileSystem MCP** - File creation, modification, and organization
- **Database MCP** - Schema changes and data migrations as needed
- **Web Testing MCP** - Automated testing for web-facing features

### `/orchestrate "complex task"`
**Purpose:** Multi-component system development using full Agent OS methodology

**Workflow:**
1. **Project Analysis** - Understand existing codebase and architecture
2. **Agent OS Planning Phase** - Create comprehensive specification and roadmap
3. **Implementation Phase** - Systematic development following Agent OS patterns
4. **Integration Phase** - Ensure components work together seamlessly
5. **Review & Optimization Phase** - Code quality, performance, and documentation
6. **Delivery Phase** - Final testing, git operations, and context preservation

## Autonomous Execution Patterns

### Error Handling & Recovery
```
Error Detected → Analyze Root Cause → Apply Fix → Re-test → Continue or Escalate
```

**Automatic Recovery Strategies:**
- **Syntax Errors** - Fix immediately and continue
- **Test Failures** - Analyze, fix code, re-run tests
- **Integration Issues** - Review dependencies, adjust integration points
- **Logic Errors** - Step back, re-examine approach, implement better solution
- **Complex Issues** - Break down into smaller problems, solve iteratively

### Quality Assurance Patterns
- **Code Review** - Automatic review against Agent OS best practices
- **Test Coverage** - Ensure comprehensive testing for all functionality
- **Documentation** - Generate documentation following Agent OS templates
- **Performance Check** - Basic performance validation for new code

### Progress Tracking
- **Phase Completion** - Mark completion of each Agent OS phase
- **Milestone Commits** - Git commits at logical progress points
- **Memory Updates** - Store key decisions and learnings
- **Context Preservation** - Maintain state for potential interruption/resumption

## MCP Orchestration in Agentic Workflows

### Intelligent MCP Selection
Different tasks leverage different MCP servers automatically:

**Code Generation Tasks:**
- FileSystem MCP for file operations
- Memory Bank MCP for pattern retrieval
- Sequential Thinking MCP for complex logic

**Database Operations:**
- Database MCP for schema and migrations
- FileSystem MCP for backup and versioning
- GitHub MCP for change tracking

**Testing & Validation:**
- Web Testing MCP for UI/API testing
- FileSystem MCP for test file management
- Memory Bank MCP for test pattern storage

### Coordinated MCP Operations
```
Task Request → MCP Server Selection → Coordinated Execution → Result Integration → Context Update
```

## Human Interaction Patterns

### Transparent Execution
- **Real-time Updates** - Show current phase and progress
- **Decision Points** - Highlight key technical decisions
- **Issue Resolution** - Display problems found and solutions applied

### Interruption & Override
- **Pause Points** - Natural stopping points for user review
- **Override Commands** - User can redirect or modify execution
- **Resume Capability** - Continue from interruption point with full context

### Review & Approval
- **Phase Summaries** - What was accomplished in each phase
- **Code Diffs** - Show all changes made during autonomous execution
- **Test Results** - Display all testing outcomes and validations

## Context-Aware Development

### Memory Integration
- **Pattern Recognition** - Learn from previous similar implementations
- **Decision History** - Reference past architectural and technical decisions
- **Code Patterns** - Reuse successful code structures and approaches

### Model Switching Support
- **State Serialization** - Capture complete execution state
- **Context Transfer** - Move autonomous workflows between models
- **Capability Mapping** - Adjust execution strategy based on model capabilities

## Workflow Customization

### Project-Specific Patterns
- **Tech Stack Awareness** - Adapt workflows for specific technologies
- **Existing Code Integration** - Work with established patterns and conventions  
- **Team Standards** - Follow project-specific coding standards and practices

### User Preference Learning
- **Style Adaptation** - Learn user's preferred code style and patterns
- **Workflow Customization** - Adapt execution flow based on user feedback
- **Tool Preferences** - Remember preferred tools and approaches

## Success Metrics

### Completion Rates
- **Successful Autonomous Completions** - Features delivered without human intervention
- **Error Recovery Success** - Issues resolved automatically during execution
- **Quality Metrics** - Code quality maintained during autonomous development

### Efficiency Gains
- **Development Speed** - Time from request to working feature
- **Context Preservation** - Successful workflow resumption across sessions
- **Learning Application** - Reuse of patterns and decisions from memory

The K83 agentic coding workflows transform AI-assisted development from interactive conversation into autonomous, goal-driven execution while maintaining the quality and structure of Agent OS methodology.